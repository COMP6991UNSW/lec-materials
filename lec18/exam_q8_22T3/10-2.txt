> Rust is too strict and too painful to be useful, as explained by this article.

The article does outline a number of valid points.

- Their comment about refactoring code after realising that a variable needs to
  be inside a Box inside a Rc inside a... is very valid -- it can be tedious
  going through and making these changes in a large program.
  - However, there have been a number of developments since the article was
    written that make this process much more bearable: The development of
    rust-analyzer, and its integration into popular text editors makes this
    process far easier. Areas which require modification are highlighted, and
    suggestions are provided that can aid in automating the process. This
    reduces the pain of writing rust dramatically.
  - I do not agree with their suggestion to "let the programmer simply declare
    a variable and explicitly specify Box or Rc where necessary". The choice to
    require the programmer to explicitly state the containers in which their
    value should be placed is, in my opinion, a good one - as it consistently
    makes you think about what restrictions exist on your value/in what
    contexts it can safely be used. This strictness does help the programmer
    write correct code without relying on tests to catch a large class of bugs.
- While it is definitely correct that the static typing rules do not guarantee
  correct execution logic, they do help dramatically by eliminating an entire
  classes of bugs which are common in languages like C/C++ (incompatible
  pointer types, object slicing (where we pass a subtype whose size is not
  known at compile-time, thus losing information), dereferencing a null
  pointer, etc). Again, rust's strictness in the development stage can reduce
  teh amount of time spent testing, and fixing, errors in the program.
- Their comment about rust's multithreading guarantees is a good example of
  where the potentially added pain during development can reduce the number of
  bugs to catch and fix during testing. The ability for a language to
  statically guarantee that data accessed across threads will be safe, and not
  lead to race conditions is extremely valuable, and again, removes an entire
  class of bugs which would otherwise need to be caught at runtime.
- "why not use sanitizers as well" -- as stated in the excerpt, sanitizers
  cannot catch all of the bugs in a program, and add a substantial runtime cost
  during testing. Rust's checks are all performed at compile-time, emitting a
  binary that is guaranteed to be memory-safe, and does not need
  sanitizing/checking at runtime. There is no (feasible) way to guarantee that
  the tests written using these sanitizers are comprehensive, and missing an
  error case may lead to the program crashing, or producing undefined
  behaviour, in production. In some applications, this may be OK -- but in
  mission-critical software, this tradeoff may be unacceptable.

On the whole, while this article does have a number of valid points, I believe
that the conclusion it draws (that rust is "an odd toy with a vague future") is
(with the benefit of an extra 7 years since the article was written),
incorrect. The strictness of rust, and the safety guarantees and developer
experience it provides, makes writing correct programs easier that using other
languages without these guarantees. In applications where correctness of a
system is vital, this provides benefits that, in my opinion, far outweigh the
potential pains of getting your program to finally build.

