I definitely agree that in some use cases, Rust's strictness can be a downside and cause
unnecessary pain for the programmer. But I also see immense value, where the situation
calls for it, in this strictness.

One painful truth of writing Rust is that it is difficult to iterate on an idea quickly.
This is because Rust's ownership, borrowing and lifetime system is something which you have
to deal with up front. Other languages which are not so eager about verifying static invariants
can let you try out program logic to see what makes most sense given the circumstance. The
article touches upon this: there is an analysis paralysis around e.g. the many smart pointers on
offer, and Rust simply refuses to play ball until you've rigorously thought through these details
of your program. So if fast development is something you value, then I can definitely see the
argument that Rust may be a painful development experience.

Some tasks are just not suited to Rust either. File parsing, for example, can be annoying, while in
other languages (e.g. Python) it can be easier without the baggage of memory correctness weighing you
down. Not every language has to be designed to solve every problem, and that is OK. It's important
to realise that each language exists with its own purposes in mind, so in that sense, I don't think that
Rust will overtake every programming language out there (though I do think C/C++, as its big competitors,
may in time be taken over).

The freedom to do whatever you want in C/C++ is also a compelling argument: it is often frustrating
when writing Rust code that has to take more low-level actions and getting knocked back by its
conversative static analysis. But this has become easier since the time this article was written in,
and I argue that these teething pains are worthwhile to experience, since if you're dealing with low-level
code you probably care about getting things right as well.

The point that tooling for other languages has evolved to the point where a lot of static checks
enjoyed by Rust can be employed is also valid, but can be argued against. Strides have definitely been
made in verification tools for these languages, and in light of the previous point, it can be to a certain
degree liberating to be able to opt into this, whereas Rust more or less forces you into ensuring your code
is "correct with a capital C". But I don't see this as a fatal blow where checks and correctness are of
interest, e.g. mission-critical contexts. I think instead this should be a celebrated aspect of the language,
because it means you don't have to bother with setting up those tools (or waiting for someone to go
and create them for you).

Rust being inherently strict isn't at all mutually exclusive with using these tools either.
Formal verification of programs is something I am a huge fan of, and one of the biggest problems when it comes
to verifying code like C/C++ is that the memory model is just so complex with many footguns. By targeting a
language that has a safer memory model, you can make formal verification of programs so much easier, and this
is the gold standard in program correctness (c.f. seL4).

So yes, Rust's strictness isn't for everybody. If you need to quickly write code and you're not particularly
worried about correctness of memory, then don't write Rust. But if you're in a performance-sensitive context
and/or one where correctness matters a great deal, then Rust's pain is instructive and can force you to write
better code, even though tools for other language theoretically exist to help you do this already.
