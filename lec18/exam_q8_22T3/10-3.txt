Rust is too strict and too painful to be useful. This sentiment stems from the fact that the Rust compiler is strict. Rust has extremely strong borrow checking, ownership and lifetime rules that can make development difficult at times. However, it is only through these restrictions that the language is able to provide its memory safety and undefined behaviour guarantees.

Main arguments by the author:
1. Rewriting C/C++ codebases in Rust. The sentiment was likely different in 2015, but today I believe most programmers do not believe in rewritting existing C/C++ codebases in Rust. As evidenced by Google's Carbon in recent years the approach going foward to deal with legaxy C codebases is to use langauges that are able to extend and interface with existing C. In this regard Rust has a high level of integration with either languages. The author is right in that rewritting legacy systems entirely in Rust would be too time consuming, however most systems are not doing this. They are using Rust for important, key functions that need to be fast and safe. Already I believe Rust is being used in the some parts of the linux kernel. Many companies and users are realising that Rust is useful for alot of use cases and are willing to accept the strictness.

2. Nesting of types especially for mulithreading is verbose. This is a valid concern. Having nested Arcs containing mutexes containing vectors can be difficult to read. However, the reason for the nesting is to provide control over exactly what features the programmer wants. This can be a pain point in rust, however it the control it provides is the opposite of strict. I find this criticism strange considering the directly following point about Rust.

3. The author does not like restrictions imposed by the language. The author states that "C++ doesnt restrict programmers regarding what they can or cannot use". This argument is extremely flawed. Firstly, C++ is an extremely bloated language as it has enforced backwards compatability for over 20 years. Rust has these restrictions in order to provide the guarantees that it can about safety. Additionally, there is the world of unsafe rust to allow some of these restrictions to be bypassed. If the author demands more for the projects they work on then Rust is not suitable for their project.

The author does not like "someone else making decisions for me" for issues like exceptions and inheritance. This is a very poor argument. All languages provide different features and functionalities that make them unique, and each have a different purpose otherwise every language would be the same. 

4. Learn how to use existing technology. The author argues that the "source of the troubles is usally in humans not technology". This is true, but where the author argues that the programmer should just "learn how to use it" Rust's approach is to help guide the programmer towards the solution rather than force improvement. There are many talks by large companies such as Microsoft on the issue of computer vulnurabilities and a large amount of them are through memory issues. If some of the largest tech companies in the world have memory issues using languages such as C/C++ who high extremely talented programmers and pay them alot of money and still have memory issues, perhaps the Rust philosophy isnt so bad. 

Rust strictness and to an extent its painfulness is a key feature of the language itself. The language does not allow what it thinks is wrong code it builds trust that if the program compiles the code is likely not wrong. Rust is not the language for every project, but where speed and  memory safety are required, it should certainly be considered, and the strictness and pain it can cause are definitely worth it.



